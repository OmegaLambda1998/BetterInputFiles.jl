var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Contents","page":"API","title":"Contents","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 5","category":"page"},{"location":"api/#InputFiles-Functions","page":"API","title":"InputFiles Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = InputFiles","category":"page"},{"location":"api/#Public-objects","page":"API","title":"Public objects","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [InputFiles]\nPrivate = false","category":"page"},{"location":"api/#InputFiles.setup_input-Tuple{AbstractString, Bool, InputFiles.IOModule.InputExt}","page":"API","title":"InputFiles.setup_input","text":"setup_input(input_path::AbstractString, verbose::Bool, ext::InputExt; paths::OrderedDict{String, Tuple{String, String}}=OrderedDict{String, Tuple{String, String}}(), log_path::String=\"output_path\", custom_metadata::Vector{Tuple{String, String}}=Vector{Tuple{String, String}}())\n\nMain InputFiles function, given a path to an input file, this will preprocess, load, and postprocess the input file, including setting up paths and logging.\n\nArguments\n\ninput_path::AbstractString: Path to input file\nverbose::Bool: Whether to log @debug messages\next::InputExt: Extension specifier\npaths::OrderedDict{String, Tuple{String, String}}=OrderedDict{String, Tuple{String, String}}: Paths to expand. paths will be merged with SetupModule.default_paths, with paths taking preference. See SetupModule.default_paths for the syntax of paths\nlog_path::String=\"output_path\": The \"path_name\" of the directory where logging should output. log_path must exist in paths or, be defined by SetupModule.default_paths\ncustom_metadata::Vector{Tuple{String, String}}=Vector{Tuple{String, String}}(): Additonal metadata to include in the input file, in addition to creation date and input_path\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.setup_input-Tuple{AbstractString, Bool, String}","page":"API","title":"InputFiles.setup_input","text":"setup_input(input_path::AbstractString, verbose::Bool, ext::String; paths::OrderedDict{String, Tuple{String, String}}=OrderedDict{String, Tuple{String, String}}(), log_path::String=\"output_path\", custom_metadata::Vector{Tuple{String, String}}=Vector{Tuple{String, String}}())\n\nManually specify input file extension, then run setup_input(::AbstractString, ::Bool, ::InputExt, ::OrderedDict{String, Tuple{String, String}}, ::String, ::Vector{Tuple{String, String}})\n\nArguments\n\ninput_path::AbstractString: Path to input file\nverbose::Bool: Whether to log @debug messages\next::String: Manual extension specifier\npaths::OrderedDict{String, Tuple{String, String}}=OrderedDict{String, Tuple{String, String}}: Paths to expand. paths will be merged with SetupModule.default_paths, with paths taking preference. See SetupModule.default_paths for the syntax of paths\nlog_path::String=\"output_path\": The \"path_name\" of the directory where logging should output. log_path must exist in paths or, be defined by SetupModule.default_paths\ncustom_metadata::Vector{Tuple{String, String}}=Vector{Tuple{String, String}}(): Additonal metadata to include in the input file, in addition to creation date and input_path\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.setup_input-Tuple{AbstractString, Bool}","page":"API","title":"InputFiles.setup_input","text":"setup_input(input_path::AbstractString, verbose::Bool; paths::OrderedDict{String, Tuple{String, String}}=OrderedDict{String, Tuple{String, String}}(), log_path::String=\"output_path\", custom_metadata::Vector{Tuple{String, String}}=Vector{Tuple{String, String}}())\n\nAutomatically choose input file extension, then run setup_input(::AbstractString, ::Bool, ::InputExt, ::OrderedDict{String, Tuple{String, String}}, ::String, ::Vector{Tuple{String, String}})\n\nArguments\n\ninput_path::AbstractString: Path to input file\nverbose::Bool: Whether to log @debug messages\npaths::OrderedDict{String, Tuple{String, String}}=OrderedDict{String, Tuple{String, String}}: Paths to expand. paths will be merged with SetupModule.default_paths, with paths taking preference. See SetupModule.default_paths for the syntax of paths\nlog_path::String=\"output_path\": The \"path_name\" of the directory where logging should output. log_path must exist in paths or, be defined by SetupModule.default_paths\ncustom_metadata::Vector{Tuple{String, String}}=Vector{Tuple{String, String}}(): Additonal metadata to include in the input file, in addition to creation date and input_path\n\n\n\n\n\n","category":"method"},{"location":"api/#Setup-Functions","page":"API","title":"Setup Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = InputFiles.SetupModule","category":"page"},{"location":"api/#Public-objects-2","page":"API","title":"Public objects","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SetupModule]\nPrivate = false","category":"page"},{"location":"api/#InputFiles.SetupModule.setup_global!","page":"API","title":"InputFiles.SetupModule.setup_global!","text":"setup_global!(input::Dict, input_path::AbstractString, verbose::Bool, paths::OrderedDict{String, Tuple{String, String}}=OrderedDict{String, Tuple{String, String}}(), log_path::String=\"OUTPUT_PATH\"; test::Bool=false)\n\nSetup the \"GLOBAL\" information of input, including paths and logging.\n\nArguments\n\ninput::Dict: The input file loaded into a Dict\ninput_path::AbstractString: The path to the input .input file (from which input is loaded)\nverbose::Bool: Whether or not to display @debug calls\npaths::OrderedDict{String, Tuple{String, String}}: Paths to expand. paths will be merged with the following default_paths, with paths taking preference. See default_paths for the syntax of paths\nlog_path::String: The \"path_name\" of the directory where logging should output\ntest::Bool: Whether this run is a test or not. This will decide whether to actually create directories, or log anything\n\nSee also setup_paths!, and setup_logging!\n\n\n\n\n\n","category":"function"},{"location":"api/#Private-objects","page":"API","title":"Private objects","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [SetupModule]\nPublic = false","category":"page"},{"location":"api/#InputFiles.SetupModule.default_paths","page":"API","title":"InputFiles.SetupModule.default_paths","text":"default_paths::OrderedDict{String, Tuple{String, String}}\n\nThe default paths which will be expanded into absolute paths and used throughout the project.\n\ndefault_paths::OrderedDict{String, Tuple{String, String}} = OrderedDict{String, Tuple{String, String}}(\n    # Name => relative, default\n    \"BASE_PATH\" => (\"INPUT_PATH\", \"\"),\n    \"OUTPUT_PATH\" => (\"BASE_PATH\", \"Output\")\n)\n\nThis dictionary maps (\"path_name\" => (\"relative_name\", \"default_path\")), where \"path_name\" is a human readable name for the path, \"relative_name\" is the name of the path which \"path_name\" is relative to, and \"default_path\" is the default value for the path (either absolute or relative). If \"path_name\" already exists inside input[\"GLOBAL\"], then that path will be used either as is (if an absolute path) or relative to \"relative_name\", otherwise the \"default_path\" will be used\n\n\n\n\n\n","category":"constant"},{"location":"api/#InputFiles.SetupModule.setup_logger-Tuple{AbstractString, Bool}","page":"API","title":"InputFiles.SetupModule.setup_logger","text":"setup_logger(log_file::AbstractString, verbose::Bool)\n\nHelper function which sets up Logger formating and log level\n\nArguments\n\nlog_file::AbstractString: Path to log file\nverbose::Bool: Whether or not to display @debug calls\n\nSee also setup_logging! and setup_global!\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.SetupModule.setup_logging!","page":"API","title":"InputFiles.SetupModule.setup_logging!","text":"setup_logging!(input::Dict, output_path::String=\"OUTPUT_PATH\"; log::Bool=true)\n\nHelper function which sets up log level, log files, etc... Assumes that setup_paths! has already been run on input\n\nArguments\n\ninput::Dict: The input file we are modifying. This assumes that the input already has a \"GLOBAL\" key with value Dict{String, Any}(\"INPUT_PATH\"=>\"/path/to/input\"), where\"INPUT_PATH\"` is the path to the input file\noutput_path::String: The \"path_name\" of the output directory where log files should be written. See default_paths for more details\n\nSee also setup_global!\n\n\n\n\n\n","category":"function"},{"location":"api/#InputFiles.SetupModule.setup_paths!-Tuple{Dict, OrderedCollections.OrderedDict{String, Tuple{String, String}}}","page":"API","title":"InputFiles.SetupModule.setup_paths!","text":"setup_paths!(input::Dict, paths::OrderedDict{String, Tuple{String, String}})\n\nHelper function which sets up paths, expanding relative paths and ensuring all interim directories exist\n\nArguments\n\ninput::Dict: The input file we are modifying. This assumes that the input already has a \"GLOBAL\" key with value Dict{String, Any}(\"INPUT_PATH\"=>\"/path/to/input\"), where\"INPUT_PATH\"is the path to theinput` file\npaths::OrderedDict{String, Tuple{String, String}}: Paths to expand. paths will be merged with the following default_paths, with paths taking preference. See default_paths for a the syntax of paths\n\nSee also setup_global!\n\n\n\n\n\n","category":"method"},{"location":"api/#IO-Functions","page":"API","title":"IO Functions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = InputFiles.IOModule","category":"page"},{"location":"api/#Public-objects-3","page":"API","title":"Public objects","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [IOModule]\nPrivate = false","category":"page"},{"location":"api/#InputFiles.IOModule.InputExt","page":"API","title":"InputFiles.IOModule.InputExt","text":"InputExt\n\nAbstract type for input extensions. Extended by TOMLExt, JSONExt, and YAMLExt. Extend to add functionality for other input types. Names are assumed to be of the form EXTENSIONExt for .extension, i.e the extension in uppercase followed by Ext.\n\n\n\n\n\n","category":"type"},{"location":"api/#InputFiles.IOModule.get_InputExt-Tuple{String}","page":"API","title":"InputFiles.IOModule.get_InputExt","text":"get_InputExt(ext::String)\n\nConverts from '.extension' to InputExt subtype.\n\nArguments\n\next::String: '.extension' to convert to InputExt subtype\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_input-Tuple{String, InputFiles.IOModule.JSONExt}","page":"API","title":"InputFiles.IOModule.load_input","text":"load_input(raw_input::String, ext::JSONExt)\n\nRead .json file in to Dict\n\nArguments\n\nraw_input::String: Raw input to load\next::JSONExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_input-Tuple{String, InputFiles.IOModule.TOMLExt}","page":"API","title":"InputFiles.IOModule.load_input","text":"load_input(raw_input::String, ext::TOMLExt)\n\nRead raw .toml file in to Dict\n\nArguments\n\nraw_input::AbstractString: Raw input to load\next::TOMLExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_input-Tuple{String, InputFiles.IOModule.YAMLExt}","page":"API","title":"InputFiles.IOModule.load_input","text":"load_input(raw_input::String, ext::YAMLExt)\n\nRead .yaml file in to Dict\n\nArguments\n\nraw_input::String: Raw input to load\next::YAMLExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_inputfile-Tuple{AbstractString, InputFiles.IOModule.JSONExt}","page":"API","title":"InputFiles.IOModule.load_inputfile","text":"load_input(input_path::AbstractString, ext::JSONExt)\n\nRead .json file in to Dict\n\nArguments\n\ninput_path::AbstractString: Input path to load\next::JSONExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_inputfile-Tuple{AbstractString, InputFiles.IOModule.TOMLExt}","page":"API","title":"InputFiles.IOModule.load_inputfile","text":"load_input(input_path::AbstractString, ext::TOMLExt)\n\nRead .toml file in to Dict\n\nArguments\n\ninput_path::AbstractString: Input path to load\next::TOMLExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_inputfile-Tuple{AbstractString, InputFiles.IOModule.YAMLExt}","page":"API","title":"InputFiles.IOModule.load_inputfile","text":"load_input(input_path::AbstractString, ext::YAMLExt)\n\nRead .yaml file in to Dict\n\nArguments\n\ninput_path::AbstractString: Input path to load\next::YAMLExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_inputfile-Tuple{AbstractString, String}","page":"API","title":"InputFiles.IOModule.load_inputfile","text":"load_input(input_path::AbstractString, ext::String)\n\nConvert ext to InputExt, then attempt to load input into a dictionary\n\nArguments\n\ninput_path::AbstractString: Input path to load\next::String: Extension string\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_inputfile-Tuple{AbstractString}","page":"API","title":"InputFiles.IOModule.load_inputfile","text":"load_input(input_path::AbstractString)\n\nAutomatically detect extension and attempt to load input into a dictionary\n\nArguments\n\ninput_path::AbstractString: Input path to load\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.load_raw_inputfile-Tuple{AbstractString}","page":"API","title":"InputFiles.IOModule.load_raw_inputfile","text":"load_raw_inputfile(input_path::AbstractString)\n\nLoads in the raw text in input_path\n\nArguments\n\ninput_path::AbstractString: Input path to load\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.postprocess_input-Tuple{Dict}","page":"API","title":"InputFiles.IOModule.postprocess_input","text":"postprocess_input(input::Dict)\n\nRun postprocessing on input\n\nArguments\n\ninput::Dict: Input to postprocess\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.preprocess_input","page":"API","title":"InputFiles.IOModule.preprocess_input","text":"preprocess_input(input_path::AbstractString, ext::String)\n\nSpecify the extension type of input_path manually, then preprocess the ipnut.\n\nArguments\n\ninput_path::AbstractString: Input file to preprocess\next::String: Manually selected extension. Must be part of exts\n\nIf the extension of input_path is not defined by InputFiles, but acts like a defined extension, you can specify which extension to use via this function, which will then run preprocess_input(::AbstractString, ::String)\n\n\n\n\n\n","category":"function"},{"location":"api/#InputFiles.IOModule.preprocess_input-2","page":"API","title":"InputFiles.IOModule.preprocess_input","text":"preprocess_input(input_path::AbstractString, ext::InputExt)\n\nPreprocess the input path before running setup.\n\nArguments\n\ninput_path::AbstractString: Input file to preprocess\next::InputExt: Extension type of input file\n\nPreprocessing includes adding metadata comments at the top-level, including other files, inserting environmental variables, propegating default values, interpolating values, and ensuring all variables are upper-case.\n\n\n\n\n\n","category":"function"},{"location":"api/#InputFiles.IOModule.preprocess_input-3","page":"API","title":"InputFiles.IOModule.preprocess_input","text":"preprocess_input(input_path::AbstractString)\n\nAutomatically detect extension type of input_path, then preprocess the input.\n\nArguments\n\ninput_path::AbstractString: Input file to preprocess\n\nWill error if the extension of input_path is not part of exts. If you wish to manually specify the extension, use [preprocess_input(::AbstractString, ::String)](@ref). After the extension is found, will run [preprocess_input(::AbstractString, ::String)](@ref) \n\n\n\n\n\n","category":"function"},{"location":"api/#InputFiles.IOModule.save_input-Tuple{Dict{String, Any}, AbstractString, InputFiles.IOModule.JSONExt}","page":"API","title":"InputFiles.IOModule.save_input","text":"save_input(input::Dict, output_file::AbstractString, ext::JSONExt)\n\nSave input to output_file, as a .json file\n\nArguments\n\ninput::Dict: Input to save\noutput_file::AbstractString: Path to save\next::JSONExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.save_input-Tuple{Dict{String, Any}, AbstractString, InputFiles.IOModule.TOMLExt}","page":"API","title":"InputFiles.IOModule.save_input","text":"save_input(input::Dict, output_file::AbstractString, ext::TOMLExt)\n\nSave input to output_file, as a .toml file\n\nArguments\n\ninput::Dict: Input to save\noutput_file::AbstractString: Path to save\next::TOMLExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.save_input-Tuple{Dict{String, Any}, AbstractString, InputFiles.IOModule.YAMLExt}","page":"API","title":"InputFiles.IOModule.save_input","text":"save_input(input::Dict, output_file::AbstractString, ext::YAMLExt)\n\nSave input to output_file, as a .yaml file\n\nArguments\n\ninput::Dict: Input to save\noutput_file::AbstractString: Path to save\next::YAMLExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.save_input-Tuple{Dict{String, Any}, String, AbstractString, InputFiles.IOModule.InputExt}","page":"API","title":"InputFiles.IOModule.save_input","text":"save_input(input::Dict, log_path::String, input_path::AbstractString, ext::InputExt)\n\nSave input to the same directory that logging is being saved.\n\nArguments\n\ninput::Dict: Input to save\nlog_path::String: Directory to save input to\ninput_path::AbstractString: Original path of input\next::InputExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#Private-objects-2","page":"API","title":"Private objects","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [IOModule]\nPublic = false","category":"page"},{"location":"api/#InputFiles.IOModule.exts","page":"API","title":"InputFiles.IOModule.exts","text":"exts::Vector{String}\n\nConvencience list of all '.extension' file extensions for each defined subtype of InputExt.\n\n\n\n\n\n","category":"constant"},{"location":"api/#InputFiles.IOModule.input_exts","page":"API","title":"InputFiles.IOModule.input_exts","text":"input_exts::Vector{InputExt}\n\nConvenience list of all InputExt subtypes defined.\n\n\n\n\n\n","category":"constant"},{"location":"api/#InputFiles.IOModule.JSONExt","page":"API","title":"InputFiles.IOModule.JSONExt","text":"JSONExt <: InputExt\n\nInputExt subtype for .json files.\n\n\n\n\n\n","category":"type"},{"location":"api/#InputFiles.IOModule.TOMLExt","page":"API","title":"InputFiles.IOModule.TOMLExt","text":"TOMLExt <: InputExt\n\nInputExt subtype for .toml files.\n\n\n\n\n\n","category":"type"},{"location":"api/#InputFiles.IOModule.YAMLExt","page":"API","title":"InputFiles.IOModule.YAMLExt","text":"YAMLExt <: InputExt\n\n[InputExt] for .yaml files.\n\n\n\n\n\n","category":"type"},{"location":"api/#InputFiles.IOModule.add_metadata","page":"API","title":"InputFiles.IOModule.add_metadata","text":"add_metadata(raw::String, ext::JSONExt, input_path::AbstractString)\n\nAdd metadata comment to top-level of .json file\n\nArguments\n\nraw::String: Raw text of input file\next::JSONExt: Extension of input file\ninput_path::AbstractString: Path to input file\n\nAdds a new \"METADATA\" key, containing the date of creation and input_path \n\n\n\n\n\n","category":"function"},{"location":"api/#InputFiles.IOModule.add_metadata-2","page":"API","title":"InputFiles.IOModule.add_metadata","text":"add_metadata(raw::String, ext::TOMLExt, input_path::AbstractString)\n\nAdd metadata comment to top-level of .toml file\n\nArguments\n\nraw::String: Raw text of input file\next::TOMLExt: Extension of input file\ninput_path::AbstractString: Path to input file\n\nAdds a new \"METADATA\" key, containing the date of creation and input_path \n\n\n\n\n\n","category":"function"},{"location":"api/#InputFiles.IOModule.add_metadata-3","page":"API","title":"InputFiles.IOModule.add_metadata","text":"add_metadata(raw::String, ext::YAMLExt, input_path::AbstractString)\n\nAdd metadata comment to top-level of .yaml file\n\nArguments\n\nraw::String: Raw text of input file\next::YAMLExt: Extension of input file\ninput_path::AbstractString: Path to input file\n\nAdds a new \"METADATA\" key, containing the date of creation and input_path \n\n\n\n\n\n","category":"function"},{"location":"api/#InputFiles.IOModule.fix_dict_type-Tuple{Dict}","page":"API","title":"InputFiles.IOModule.fix_dict_type","text":"fix_dict_type(input::Dict)\n\nEnsure dictionary is of type Dict{String, Any}\n\nArguments\n\ninput::Dict: Input to fix\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.get_ext-Tuple{InputFiles.IOModule.InputExt}","page":"API","title":"InputFiles.IOModule.get_ext","text":"get_ext(ext::InputExt)\n\nConvert from the InputExt type to the '.extension' file extension.\n\nArguments\n\next::InputExt: The InputExt subtype to convert into a file extension\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.process_env_vars-Tuple{String}","page":"API","title":"InputFiles.IOModule.process_env_vars","text":"process_env_vars(raw::String)\n\nInterpolate environmental variables into raw, specified via <$ENV>\n\nArguments\n\nraw::String: Raw file to process\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.process_includes-Tuple{String, AbstractString}","page":"API","title":"InputFiles.IOModule.process_includes","text":"process_includes(raw::String, input_path::AbstractString)\n\nCopy include files specified via <include path/to/include.file> into raw\n\nArguments\n\nraw::String: Raw file to provess\ninput_path::AbstractString: Path to input file\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.process_interpolation-Tuple{Dict, Dict}","page":"API","title":"InputFiles.IOModule.process_interpolation","text":"process_interpolation(input::Dict)\n\nProcess interpolations for input\n\nArguments\n\ninput::Dict The input to process\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.process_interpolation-Tuple{String, InputFiles.IOModule.InputExt}","page":"API","title":"InputFiles.IOModule.process_interpolation","text":"process_interpolation(raw::String, ext::InputExt)\n\nGiven the raw string for an input, load the input (load_input), and process all interpolations (process_interpolation(::Dict)), respecting defaults\n\nArguments\n\nraw::String: The raw input file to process\next::InputExt: Extension specifier\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.update_case-Tuple{AbstractArray}","page":"API","title":"InputFiles.IOModule.update_case","text":"update_case(input::AbstractArray)\n\nUpdated the case of every element in input.\n\nArguments\n\ninput::AbstractArray: Input to process \n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.update_case-Tuple{Any}","page":"API","title":"InputFiles.IOModule.update_case","text":"update_case(input::Any)\n\nStopping condition of postprocess_input(::Dict), when a value is reached\n\nArguments\n\ninput::Any: Return input\n\n\n\n\n\n","category":"method"},{"location":"api/#InputFiles.IOModule.update_case-Tuple{Dict}","page":"API","title":"InputFiles.IOModule.update_case","text":"update_case(input::Dict)\n\nRecursively ensure every key in input is uppercase\n\nArguments\n\ninput::Dict: The input to update\n\n\n\n\n\n","category":"method"},{"location":"advanced/#Advanced-Usage","page":"Advanced Usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/#Contents","page":"Advanced Usage","title":"Contents","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Pages = [\"advanced.md\"]","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Most of my packages use the same boilerplate to setup everything in a way that allows easy access propogation of user provided parameters:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"using InputFiles\nusing ArgParse\n\nfunction get_args()\n    s = ArgParseSettings()\n    @add_arg_table s begin\n        \"--verbose\", \"-v\"\n            help = \"Increase level of logging verbosity\"\n            action = :store_true\n        \"input\"\n            help = \"Path to input file\"\n            required = true\n    end\n    return parse_args(s)\nend\n\nfunction main()\n    args = get_args()\n    verbose = args[\"verbose\"]\n    input_path = args[\"input\"]\n    input = setup_input(toml, verbose)\n    @debug \"Read in $input_path\"\n    run_MyPackage(input) # Actually run everything with the prepared `input`\nend","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Given an input file, this will produce a dictionary with a global key containing a dictionary with","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"input_path: The directory the input file is stored in\nbase_path: A base path defined relative to input_path from which any relative paths used by the package will be relative to\noutput_path: The output directory where all output, including logging, will be put\nlogging: Whether logging was set up. This allows you to use my InputFiles logging function or your own\nlog_file: If using my logging function, then in addition to stdout, logs will be saved to log_file","category":"page"},{"location":"advanced/#Input-file-options","page":"Advanced Usage","title":"Input file options","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Much of the behaviour can be controlled from the input file itself, without needed to change any code. Note that all of these examples are written in TOML, but will work for YAML, and JSON files as well.","category":"page"},{"location":"advanced/#Change-default-paths","page":"Advanced Usage","title":"Change default paths","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"By default, InputFiles sets base_path equal to input_path, and output_path equal to base_path/Output. By defining your own (absolute or relative) base_path, and output_path, you can change these defaults. Note that base_path is defined relative to input_path, and output_path is defined relative to base_path, but absolute paths are respected.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[ global ]\n    base_path = \"../Examples\"\n    # base_path = input_path/../Examples\n    output_path = \"/tmp/test\"\n    # output_path = \"/tmp/test\"","category":"page"},{"location":"advanced/#Change-logging-behaviour","page":"Advanced Usage","title":"Change logging behaviour","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"You can define in the input file, whether you want to use InputFiles logging or not. Additionally you can specify a new location for the log file (defaults to output_path/log.txt). This can be either absolute, or relative to output_path.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[ global ]\n    logging = false\n    log_file = logs/out.txt\n    # log_file = output_path/logs/out.txt","category":"page"},{"location":"advanced/#Include-another-input-file","page":"Advanced Usage","title":"Include another input file","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"It is sometimes helpful to seperate your input into a number of different files, or to use the same input options in a number of different files.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"# file_1.toml\n[ key1 ]\n    a = 1\n    b = 2\n\n# file_2.toml\n<include file_1.toml>\n\n[ key2 ]\n    c = 3\n    d = 4","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"input = setup_input(\"file_2.toml\", verbose)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Will produce:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[ key1 ]\n    a = 1\n    b = 2\n\n[ key2 ]\n    c = 3\n    d = 4","category":"page"},{"location":"advanced/#Interpolate-Environmental-Variables","page":"Advanced Usage","title":"Interpolate Environmental Variables","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"You can easily interpolate environmental variables via:","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[ key1 ]\n    a = <$A>\n    b = <$B>","category":"page"},{"location":"advanced/#Generic-Interpolation","page":"Advanced Usage","title":"Generic Interpolation","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"You can also interpolate other keys, as long as they belong to the same subtree, allowing for easy duplication.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[ key1 ]\n    a = 1\n    b = <%a>","category":"page"},{"location":"advanced/#Propogate-defaults","page":"Advanced Usage","title":"Propogate defaults","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"You can specify default values which will be available under every key. These are also quite useful when combined with interpolation, as this default value will be part of every base key. If a default key is specified already, then the default will be ignored","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"[ DEFAULT ]\n    a = 1\n    b = 2\n\n[ key1 ]\n    c = <%a>\n    d = <%b>","category":"page"},{"location":"advanced/#Automatic-upper-case","page":"Advanced Usage","title":"Automatic upper-case","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Finally, InputFiles will automatically make every key upper-case, so your user's can ignore case when specifying keys. Values are still case-specific.","category":"page"},{"location":"advanced/#Script-options","page":"Advanced Usage","title":"Script options","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"In addition to changing behaviour from the input file, there's also a lot of functionality InputFiles provides when writing scripts ","category":"page"},{"location":"advanced/#Add-new-global-paths","page":"Advanced Usage","title":"Add new global paths","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"By defining an OrderedDict{String, Tuple{String, String}} of paths, you can add new global paths, which can be accessed throughout the package. The following creates data_path relative to base_path, and filter_path relative to data_path. You must provide defaults for these paths but the user can overwrite then in the .toml (see Change default paths).","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"paths = Dict(\n    # Name of path => (relative parent, default)\n    \"data_path\" => (\"base_path\", \"Data\")\n    \"filter_path\" => (\"data_path\", \"Filters\")\n\ninput = setup_input(input_path, verbose; paths=paths) ","category":"page"},{"location":"advanced/#Custom-Metadata","page":"Advanced Usage","title":"Custom Metadata","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"By providing InputFiles with a Vector{Tuple{String, String}}, you can add additional metadata to the input file, in addition to the date of creation and original input file.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"custom_metadata = [(\"Custom\", \"Metadata\")]\n\ninput = setup_input(input_path, verbose; custom_metadata=custom_metadata)","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"This will create a new key=\"Custom\" and value=\"Metadata\" in the Metadata dictionary.","category":"page"},{"location":"advanced/#Manually-set-extension","page":"Advanced Usage","title":"Manually set extension","text":"","category":"section"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"Sometimes you will have an input file which acts like a TOML, YAML, or JSON file, but has a different extension. If this is the case, you can let InputFiles know which extension to assume.","category":"page"},{"location":"advanced/","page":"Advanced Usage","title":"Advanced Usage","text":"input = setup_input(\"/path/to/input.example\", verbose, \"toml\")","category":"page"},{"location":"#InputFiles.jl-Documentation","page":"InputFiles","title":"InputFiles.jl Documentation","text":"","category":"section"},{"location":"","page":"InputFiles","title":"InputFiles","text":"InputFiles.jl","category":"page"},{"location":"","page":"InputFiles","title":"InputFiles","text":"Provides consistent methods to load in input files, such as .toml, .yaml, and .json files. Also extends the functionality of these files, via pre-processing, and post-processing.","category":"page"},{"location":"","page":"InputFiles","title":"InputFiles","text":"Functionality provided includes:","category":"page"},{"location":"","page":"InputFiles","title":"InputFiles","text":"Automatically add Metadata to your input\nAutomatically include other input files in your input\nInterpolate environmental variables into your input\nPropegate default values throughout your input\nGenerically interpolate key's throughout your input","category":"page"},{"location":"","page":"InputFiles","title":"InputFiles","text":"I already use this in many of my projects, including IABCosmo.jl, SALTJacobian.jl, Supernovae.jl, ShockCooling.jl, and Greed.jl (amongst others).","category":"page"},{"location":"#Install","page":"InputFiles","title":"Install","text":"","category":"section"},{"location":"","page":"InputFiles","title":"InputFiles","text":"using Pkg\nPkg.add(\"InputFiles\")","category":"page"},{"location":"#Usage","page":"InputFiles","title":"Usage","text":"","category":"section"},{"location":"","page":"InputFiles","title":"InputFiles","text":"This package provides one main function, and a number of helper macros. The setup_input function does most of the heavy lifting, pre-processing, loading, and post-processing the input file you give it. An idiomatic way of using this package is as follows:","category":"page"},{"location":"","page":"InputFiles","title":"InputFiles","text":"using InputFiles\nusing DataStructures\nusing ArgParse\n\nfunction get_args()\n    s = ArgParseSettings()\n    @add_arg_table s begin\n        \"--verbose\", \"-v\"\n            help = \"Increase level of logging verbosity\"\n            action = :store_true\n        \"input\"\n            help = \"Path to input file\"\n            required = true\n    end\n    return parse_args(s)\nend\n\nfunction main()\n    args = get_args()\n    verbose = args[\"verbose\"]\n    input_path = args[\"input\"]\n    input = setup_input(input_path, verbose)\n    # Run your package with the input file\n    run_MyPackage(input)\nend","category":"page"}]
}
